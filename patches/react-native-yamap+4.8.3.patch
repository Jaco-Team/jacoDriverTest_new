diff --git a/node_modules/react-native-yamap/.idea/GitCommitMessageStorage.xml b/node_modules/react-native-yamap/.idea/GitCommitMessageStorage.xml
deleted file mode 100644
index 3b56900..0000000
--- a/node_modules/react-native-yamap/.idea/GitCommitMessageStorage.xml
+++ /dev/null
@@ -1,20 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="GitCommitMessageStorage">
-    <option name="messageStorage">
-      <MessageStorage>
-        <option name="commitTemplate">
-          <CommitTemplate>
-            <option name="body" value="" />
-            <option name="changes" value="" />
-            <option name="closes" value="" />
-            <option name="scope" value="" />
-            <option name="skipCi" value="" />
-            <option name="subject" value="" />
-            <option name="type" value="feat" />
-          </CommitTemplate>
-        </option>
-      </MessageStorage>
-    </option>
-  </component>
-</project>
\ No newline at end of file
diff --git a/node_modules/react-native-yamap/.idea/dictionaries b/node_modules/react-native-yamap/.idea/dictionaries
deleted file mode 100644
index 343c0b6..0000000
--- a/node_modules/react-native-yamap/.idea/dictionaries
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectDictionaryState">
-    <dictionary name="nikita" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/node_modules/react-native-yamap/.idea/inspectionProfiles/Project_Default.xml b/node_modules/react-native-yamap/.idea/inspectionProfiles/Project_Default.xml
deleted file mode 100644
index b3111f4..0000000
--- a/node_modules/react-native-yamap/.idea/inspectionProfiles/Project_Default.xml
+++ /dev/null
@@ -1,9 +0,0 @@
-<component name="InspectionProjectProfileManager">
-  <profile version="1.0">
-    <option name="myName" value="Project Default" />
-    <inspection_tool class="Eslint" enabled="true" level="WARNING" enabled_by_default="true" />
-    <inspection_tool class="JSMethodCanBeStatic" enabled="false" level="WARNING" enabled_by_default="false" />
-    <inspection_tool class="JSRedundantSwitchStatement" enabled="false" level="WARNING" enabled_by_default="false" />
-    <inspection_tool class="ThisExpressionReferencesGlobalObjectJS" enabled="false" level="WARNING" enabled_by_default="false" />
-  </profile>
-</component>
\ No newline at end of file
diff --git a/node_modules/react-native-yamap/.idea/jsLibraryMappings.xml b/node_modules/react-native-yamap/.idea/jsLibraryMappings.xml
deleted file mode 100644
index d23208f..0000000
--- a/node_modules/react-native-yamap/.idea/jsLibraryMappings.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="JavaScriptLibraryMappings">
-    <includedPredefinedLibrary name="Node.js Core" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/node_modules/react-native-yamap/.idea/misc.xml b/node_modules/react-native-yamap/.idea/misc.xml
deleted file mode 100644
index a62cd3d..0000000
--- a/node_modules/react-native-yamap/.idea/misc.xml
+++ /dev/null
@@ -1,75 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="MarkdownProjectSettings">
-    <PreviewSettings splitEditorLayout="SPLIT" splitEditorPreview="PREVIEW" useGrayscaleRendering="false" zoomFactor="1.0" maxImageWidth="0" showGitHubPageIfSynced="false" allowBrowsingInPreview="false" synchronizePreviewPosition="true" highlightPreviewType="NONE" highlightFadeOut="5" highlightOnTyping="true" synchronizeSourcePosition="true" verticallyAlignSourceAndPreviewSyncPosition="true" showSearchHighlightsInPreview="false" showSelectionInPreview="true">
-      <PanelProvider>
-        <provider providerId="com.vladsch.idea.multimarkdown.editor.swing.html.panel" providerName="Default - Swing" />
-      </PanelProvider>
-    </PreviewSettings>
-    <ParserSettings gitHubSyntaxChange="false">
-      <PegdownExtensions>
-        <option name="ABBREVIATIONS" value="false" />
-        <option name="ANCHORLINKS" value="true" />
-        <option name="ASIDE" value="false" />
-        <option name="ATXHEADERSPACE" value="true" />
-        <option name="AUTOLINKS" value="true" />
-        <option name="DEFINITIONS" value="false" />
-        <option name="DEFINITION_BREAK_DOUBLE_BLANK_LINE" value="false" />
-        <option name="FENCED_CODE_BLOCKS" value="true" />
-        <option name="FOOTNOTES" value="false" />
-        <option name="HARDWRAPS" value="false" />
-        <option name="HTML_DEEP_PARSER" value="false" />
-        <option name="INSERTED" value="false" />
-        <option name="QUOTES" value="false" />
-        <option name="RELAXEDHRULES" value="true" />
-        <option name="SMARTS" value="false" />
-        <option name="STRIKETHROUGH" value="true" />
-        <option name="SUBSCRIPT" value="false" />
-        <option name="SUPERSCRIPT" value="false" />
-        <option name="SUPPRESS_HTML_BLOCKS" value="false" />
-        <option name="SUPPRESS_INLINE_HTML" value="false" />
-        <option name="TABLES" value="true" />
-        <option name="TASKLISTITEMS" value="true" />
-        <option name="TOC" value="false" />
-        <option name="WIKILINKS" value="true" />
-      </PegdownExtensions>
-      <ParserOptions>
-        <option name="COMMONMARK_LISTS" value="true" />
-        <option name="DUMMY" value="false" />
-        <option name="EMOJI_SHORTCUTS" value="true" />
-        <option name="FLEXMARK_FRONT_MATTER" value="false" />
-        <option name="GFM_LOOSE_BLANK_LINE_AFTER_ITEM_PARA" value="false" />
-        <option name="GFM_TABLE_RENDERING" value="true" />
-        <option name="GITBOOK_URL_ENCODING" value="false" />
-        <option name="GITHUB_EMOJI_URL" value="false" />
-        <option name="GITHUB_LISTS" value="false" />
-        <option name="GITHUB_WIKI_LINKS" value="true" />
-        <option name="JEKYLL_FRONT_MATTER" value="false" />
-        <option name="SIM_TOC_BLANK_LINE_SPACER" value="true" />
-      </ParserOptions>
-    </ParserSettings>
-    <HtmlSettings headerTopEnabled="false" headerBottomEnabled="false" bodyTopEnabled="false" bodyBottomEnabled="false" embedUrlContent="false" addPageHeader="true">
-      <GeneratorProvider>
-        <provider providerId="com.vladsch.idea.multimarkdown.editor.swing.html.generator" providerName="Default Swing HTML Generator" />
-      </GeneratorProvider>
-      <headerTop />
-      <headerBottom />
-      <bodyTop />
-      <bodyBottom />
-    </HtmlSettings>
-    <CssSettings previewScheme="UI_SCHEME" cssUri="" isCssUriEnabled="false" isCssTextEnabled="false" isDynamicPageWidth="true">
-      <StylesheetProvider>
-        <provider providerId="com.vladsch.idea.multimarkdown.editor.swing.html.css" providerName="Default Swing Stylesheet" />
-      </StylesheetProvider>
-      <ScriptProviders />
-      <cssText />
-    </CssSettings>
-    <HtmlExportSettings updateOnSave="false" parentDir="$ProjectFileDir$" targetDir="$ProjectFileDir$" cssDir="" scriptDir="" plainHtml="false" imageDir="" copyLinkedImages="false" imageUniquifyType="0" targetExt="" useTargetExt="false" noCssNoScripts="false" linkToExportedHtml="true" exportOnSettingsChange="true" regenerateOnProjectOpen="false" />
-    <LinkMapSettings>
-      <textMaps />
-    </LinkMapSettings>
-  </component>
-  <component name="PreferredVcsStorage">
-    <preferredVcsName>ApexVCS</preferredVcsName>
-  </component>
-</project>
\ No newline at end of file
diff --git a/node_modules/react-native-yamap/.idea/modules.xml b/node_modules/react-native-yamap/.idea/modules.xml
deleted file mode 100644
index c9d05b3..0000000
--- a/node_modules/react-native-yamap/.idea/modules.xml
+++ /dev/null
@@ -1,8 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="ProjectModuleManager">
-    <modules>
-      <module fileurl="file://$PROJECT_DIR$/.idea/react-native-yamap.iml" filepath="$PROJECT_DIR$/.idea/react-native-yamap.iml" />
-    </modules>
-  </component>
-</project>
\ No newline at end of file
diff --git a/node_modules/react-native-yamap/.idea/react-native-yamap.iml b/node_modules/react-native-yamap/.idea/react-native-yamap.iml
deleted file mode 100644
index 0c8867d..0000000
--- a/node_modules/react-native-yamap/.idea/react-native-yamap.iml
+++ /dev/null
@@ -1,12 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<module type="WEB_MODULE" version="4">
-  <component name="NewModuleRootManager">
-    <content url="file://$MODULE_DIR$">
-      <excludeFolder url="file://$MODULE_DIR$/temp" />
-      <excludeFolder url="file://$MODULE_DIR$/.tmp" />
-      <excludeFolder url="file://$MODULE_DIR$/tmp" />
-    </content>
-    <orderEntry type="inheritedJdk" />
-    <orderEntry type="sourceFolder" forTests="false" />
-  </component>
-</module>
\ No newline at end of file
diff --git a/node_modules/react-native-yamap/.idea/vcs.xml b/node_modules/react-native-yamap/.idea/vcs.xml
deleted file mode 100644
index 94a25f7..0000000
--- a/node_modules/react-native-yamap/.idea/vcs.xml
+++ /dev/null
@@ -1,6 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<project version="4">
-  <component name="VcsDirectoryMappings">
-    <mapping directory="$PROJECT_DIR$" vcs="Git" />
-  </component>
-</project>
\ No newline at end of file
diff --git a/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/ClusteredYamapViewManager.kt b/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/ClusteredYamapViewManager.kt
index 54d8a0f..b58b809 100644
--- a/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/ClusteredYamapViewManager.kt
+++ b/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/ClusteredYamapViewManager.kt
@@ -128,7 +128,10 @@ class ClusteredYamapViewManager internal constructor() : ViewGroupManager<Cluste
             }
 
             "findRoutes" -> if (args != null) {
-                findRoutes(view, args.getArray(0), args.getArray(1), args.getString(2))
+                val p0 = args.getArray(0) ?: com.facebook.react.bridge.Arguments.createArray()
+                val p1 = args.getArray(1) ?: com.facebook.react.bridge.Arguments.createArray()
+                val sid = args.getString(2) ?: ""
+                findRoutes(view, p0, p1, sid)
             }
 
             "setZoom" -> if (args != null) {
@@ -151,12 +154,28 @@ class ClusteredYamapViewManager internal constructor() : ViewGroupManager<Cluste
                 view.setTrafficVisible(args.getBoolean(0))
             }
 
-            "getScreenPoints" -> if (args != null) {
-                view.emitWorldToScreenPoints(args.getArray(0), args.getString(1))
+            "getScreenPoints" -> args?.let { currentArgs -> // currentArgs это 'args', но не null
+                val pointsArray = currentArgs.getArray(0)
+                val callbackId = currentArgs.getString(1) // Также проверьте nullability callbackId
+
+                if (pointsArray != null && callbackId != null) {
+                    view.emitWorldToScreenPoints(pointsArray, callbackId)
+                } else {
+                    // Обработка null
+                    //Log.e("YamapViewManager", "pointsArray or callbackId is null inside let for getScreenPoints")
+                }
             }
 
-            "getWorldPoints" -> if (args != null) {
-                view.emitScreenToWorldPoints(args.getArray(0), args.getString(1))
+            "getWorldPoints" -> args?.let { currentArgs ->
+                val pointsArray = currentArgs.getArray(0)
+                val callbackId = currentArgs.getString(1)
+
+                if (pointsArray != null && callbackId != null) {
+                    view.emitScreenToWorldPoints(pointsArray, callbackId)
+                } else {
+                    // Обработка null
+                    //Log.e("YamapViewManager", "pointsArray or callbackId is null inside let for getWorldPoints")
+                }
             }
 
             else -> throw IllegalArgumentException(
@@ -171,7 +190,22 @@ class ClusteredYamapViewManager internal constructor() : ViewGroupManager<Cluste
 
     @ReactProp(name = "clusteredMarkers")
     fun setClusteredMarkers(view: View, points: ReadableArray) {
-        castToYaMapView(view).setClusteredMarkers(points.toArrayList())
+        val arrayList = points.toArrayList()
+        // Пример: если null означает, что маркер нужно пропустить, или если у вас есть
+        // объект-заполнитель по умолчанию для null.
+        // mapNotNull уберет null результаты преобразования.
+        val processedArrayList = arrayList.mapNotNull { item ->
+            if (item == null) {
+                // null // Пропустить этот элемент
+                // или
+                // YourDefaultMarkerObject() // Заменить null на объект по умолчанию
+                null // В данном примере просто пропускаем
+            } else {
+                item // Оставить не-null элементы как есть
+            }
+        } as ArrayList<Any> // Приведение типа после обработки
+
+        castToYaMapView(view).setClusteredMarkers(processedArrayList)
     }
 
     @ReactProp(name = "clusterColor")
@@ -233,20 +267,32 @@ class ClusteredYamapViewManager internal constructor() : ViewGroupManager<Cluste
         id: String
     ) {
         if (jsPoints != null) {
+            // Явно указываем, что список может содержать null, хотя мы будем добавлять только не-null Point
             val points = ArrayList<Point?>()
             for (i in 0 until jsPoints.size()) {
-                val point = jsPoints.getMap(i)
-                if (point != null) {
-                    points.add(Point(point.getDouble("lat"), point.getDouble("lon")))
+                val pointMap = jsPoints.getMap(i)
+                if (pointMap != null) {
+                    points.add(Point(pointMap.getDouble("lat"), pointMap.getDouble("lon"))) // Добавляем не-null Point
                 }
+                // Если бы вы хотели добавить null при pointMap == null, вы бы сделали это здесь:
+                // else {
+                //     points.add(null)
+                // }
+                // Но согласно вашей логике, вы просто пропускаете null pointMap.
             }
+
             val vehicles = ArrayList<String>()
             if (jsVehicles != null) {
                 for (i in 0 until jsVehicles.size()) {
-                    vehicles.add(jsVehicles.getString(i))
+                    val vehicleString = jsVehicles.getString(i)
+                    if (vehicleString != null) {
+                        vehicles.add(vehicleString)
+                    } else {
+                        // Log.w("YamapViewManager", "Null vehicle type received and skipped for route $id")
+                    }
                 }
             }
-            castToYaMapView(view).findRoutes(points, vehicles, id)
+            castToYaMapView(view).findRoutes(points, vehicles, id) // Теперь тип 'points' должен совпадать с ожидаемым
         }
     }
 
diff --git a/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/YamapMarkerManager.kt b/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/YamapMarkerManager.kt
index e32d22c..2156e88 100644
--- a/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/YamapMarkerManager.kt
+++ b/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/YamapMarkerManager.kt
@@ -107,17 +107,42 @@ class YamapMarkerManager internal constructor() : ViewGroupManager<YamapMarker>(
     ) {
         when (commandType) {
             "animatedMoveTo" -> {
-                val markerPoint = args!!.getMap(0)
-                val moveDuration = args.getInt(1)
-                val lon = markerPoint.getDouble("lon").toFloat()
-                val lat = markerPoint.getDouble("lat").toFloat()
-                val point = Point(lat.toDouble(), lon.toDouble())
-                castToMarkerView(view).animatedMoveTo(point, moveDuration.toFloat())
+                // 1. Проверяем args на null и на наличие достаточного количества элементов
+                if (args == null || args.size() < 2) {
+                    // Логируем ошибку или отправляем событие об ошибке обратно в React Native
+                    // Log.e(REACT_CLASS, "animatedMoveTo: Invalid or insufficient arguments received.")
+                    return // Выходим, если аргументы некорректны
+                }
+
+                // 2. Безопасно получаем карту markerPoint и проверяем её на null
+                val markerPointMap: ReadableMap? = args.getMap(0) // Явно указываем тип для ясности
+                if (markerPointMap == null) {
+                    // Log.e(REACT_CLASS, "animatedMoveTo: markerPointMap at index 0 is null.")
+                    return // Выходим, если карта не найдена
+                }
+
+                // Теперь мы уверены, что markerPointMap не null
+                // getDouble и getInt из ReadableMap/ReadableArray вернут 0.0 или 0, если ключ отсутствует или тип не тот.
+                // Если вам нужна более строгая обработка, используйте hasKey() и getType().
+                val lon = markerPointMap.getDouble("lon")
+                val lat = markerPointMap.getDouble("lat")
+                val moveDuration = args.getInt(1) // Это безопасно, так как мы проверили args.size() < 2
+
+                // Конструктор Point ожидает Double, getDouble уже возвращает Double.
+                // toFloat().toDouble() было избыточным и могло приводить к потере точности.
+                val point = Point(lat, lon)
+                castToMarkerView(view).animatedMoveTo(point, moveDuration.toFloat()) // moveDuration должен быть Float
                 return
             }
 
             "animatedRotateTo" -> {
-                val angle = args!!.getInt(0)
+                // 1. Проверяем args на null и на наличие достаточного количества элементов
+                if (args == null || args.size() < 2) {
+                    // Log.e(REACT_CLASS, "animatedRotateTo: Invalid or insufficient arguments received.")
+                    return
+                }
+
+                val angle = args.getInt(0)
                 val rotateDuration = args.getInt(1)
                 castToMarkerView(view).animatedRotateTo(angle.toFloat(), rotateDuration.toFloat())
                 return
@@ -125,7 +150,8 @@ class YamapMarkerManager internal constructor() : ViewGroupManager<YamapMarker>(
 
             else -> throw IllegalArgumentException(
                 String.format(
-                    "Unsupported command %d received by %s.",
+                    // Исправляем %d на %s для commandType, так как это строка
+                    "Unsupported command %s received by %s.",
                     commandType,
                     javaClass.simpleName
                 )
@@ -133,6 +159,7 @@ class YamapMarkerManager internal constructor() : ViewGroupManager<YamapMarker>(
         }
     }
 
+
     companion object {
         const val REACT_CLASS: String = "YamapMarker"
     }
diff --git a/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/YamapViewManager.kt b/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/YamapViewManager.kt
index 8b05905..6edd700 100644
--- a/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/YamapViewManager.kt
+++ b/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/YamapViewManager.kt
@@ -127,8 +127,14 @@ class YamapViewManager internal constructor() : ViewGroupManager<YamapView>() {
                 fitMarkers(view, args.getArray(0))
             }
 
-            "findRoutes" -> if (args != null) {
-                findRoutes(view, args.getArray(0), args.getArray(1), args.getString(2))
+            "findRoutes" -> if (args != null && args.size() >= 3) { // Добавим проверку на размер
+                val routeId = args.getString(2)
+                if (routeId != null) {
+                    findRoutes(view, args.getArray(0), args.getArray(1), routeId)
+                } else {
+                    // Обработка: id не предоставлен. Можно залогировать или ничего не делать.
+                    // Log.w(REACT_CLASS, "findRoutes: routeId is null")
+                }
             }
 
             "setZoom" -> if (args != null) {
@@ -151,14 +157,29 @@ class YamapViewManager internal constructor() : ViewGroupManager<YamapView>() {
                 view.setTrafficVisible(args.getBoolean(0))
             }
 
-            "getScreenPoints" -> if (args != null) {
-                view.emitWorldToScreenPoints(args.getArray(0), args.getString(1))
+            "getScreenPoints" -> if (args != null && args.size() >= 2) { // Проверка размера
+                val pointsArray = args.getArray(0)
+                val callbackId = args.getString(1)
+                if (pointsArray != null && callbackId != null) {
+                    view.emitWorldToScreenPoints(pointsArray, callbackId)
+                } else {
+                    // Обработка: один из аргументов null
+                    // Log.w(REACT_CLASS, "getScreenPoints: pointsArray or callbackId is null")
+                }
             }
 
-            "getWorldPoints" -> if (args != null) {
-                view.emitScreenToWorldPoints(args.getArray(0), args.getString(1))
+            "getWorldPoints" -> if (args != null && args.size() >= 2) { // Проверка размера
+                val pointsArray = args.getArray(0)
+                val callbackId = args.getString(1)
+                if (pointsArray != null && callbackId != null) {
+                    view.emitScreenToWorldPoints(pointsArray, callbackId)
+                } else {
+                    // Обработка: один из аргументов null
+                    // Log.w(REACT_CLASS, "getWorldPoints: pointsArray or callbackId is null")
+                }
             }
 
+
             else -> throw IllegalArgumentException(
                 String.format(
                     "Unsupported command %d received by %s.",
@@ -225,26 +246,30 @@ class YamapViewManager internal constructor() : ViewGroupManager<YamapView>() {
     ) {
         if (jsPoints != null) {
             val points = ArrayList<Point?>()
-
             for (i in 0 until jsPoints.size()) {
-                val point = jsPoints.getMap(i)
-                if (point != null) {
-                    points.add(Point(point.getDouble("lat"), point.getDouble("lon")))
+                val pointMap = jsPoints.getMap(i)
+                if (pointMap != null) {
+                    points.add(Point(pointMap.getDouble("lat"), pointMap.getDouble("lon")))
                 }
             }
 
             val vehicles = ArrayList<String>()
-
             if (jsVehicles != null) {
                 for (i in 0 until jsVehicles.size()) {
-                    vehicles.add(jsVehicles.getString(i))
+                    val vehicleString = jsVehicles.getString(i)
+                    if (vehicleString != null) { // Добавляем только если не null
+                        vehicles.add(vehicleString)
+                    } else {
+                        // Опционально: обработать случай, когда строка null
+                        // Log.w(REACT_CLASS, "findRoutes: Null vehicle type received and skipped for route $id")
+                    }
                 }
             }
-
             castToYaMapView(view).findRoutes(points, vehicles, id)
         }
     }
 
+
     // PROPS
     @ReactProp(name = "userLocationIcon")
     fun setUserLocationIcon(view: View, icon: String?) {
diff --git a/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/view/YamapView.kt b/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/view/YamapView.kt
index 48c1cdf..85eff5e 100644
--- a/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/view/YamapView.kt
+++ b/node_modules/react-native-yamap/android/src/main/java/ru/vvdev/yamap/view/YamapView.kt
@@ -17,8 +17,6 @@ import com.facebook.react.bridge.WritableNativeArray
 import com.facebook.react.uimanager.events.RCTEventEmitter
 import com.yandex.mapkit.Animation
 import com.yandex.mapkit.MapKitFactory
-import com.yandex.mapkit.RequestPoint
-import com.yandex.mapkit.RequestPointType
 import com.yandex.mapkit.ScreenPoint
 import com.yandex.mapkit.directions.DirectionsFactory
 import com.yandex.mapkit.directions.driving.DrivingOptions
@@ -45,7 +43,6 @@ import com.yandex.mapkit.map.IconStyle
 import com.yandex.mapkit.map.InputListener
 import com.yandex.mapkit.map.MapLoadStatistics
 import com.yandex.mapkit.map.MapLoadedListener
-import com.yandex.mapkit.map.MapObjectCollection
 import com.yandex.mapkit.map.MapType
 import com.yandex.mapkit.map.PlacemarkMapObject
 import com.yandex.mapkit.map.VisibleRegion
@@ -73,843 +70,773 @@ import ru.vvdev.yamap.models.ReactMapObject
 import ru.vvdev.yamap.utils.Callback
 import ru.vvdev.yamap.utils.ImageLoader.DownloadImageBitmap
 import ru.vvdev.yamap.utils.RouteManager
-import java.util.Objects
 import javax.annotation.Nonnull
 
-
-open class YamapView(context: Context?) : MapView(context), UserLocationObjectListener,
-    CameraListener, InputListener, TrafficListener, MapLoadedListener {
-    private var mViewParent: ViewParent? = null
-    private var userLocationIcon = ""
-    private var userLocationIconScale = 1f
-    private var userLocationBitmap: Bitmap? = null
-    private val routeMng = RouteManager()
-    private var routeOptions: RouteOptions = RouteOptions(FitnessOptions(false))
-    private val masstransitRouter = TransportFactory.getInstance().createMasstransitRouter()
-    private val drivingRouter: DrivingRouter
-    private val pedestrianRouter = TransportFactory.getInstance().createPedestrianRouter()
-    private var userLocationLayer: UserLocationLayer? = null
-    private var userLocationAccuracyFillColor = 0
-    private var userLocationAccuracyStrokeColor = 0
-    private var userLocationAccuracyStrokeWidth = 0f
-    private var trafficLayer: TrafficLayer? = null
-    private var maxFps = 60f
-    private var initializedRegion = false;
-
-    private var userLocationView: UserLocationView? = null
-
-    init {
-        drivingRouter = DirectionsFactory.getInstance().createDrivingRouter(DrivingRouterType.ONLINE)
-        mapWindow.map.addCameraListener(this)
-        mapWindow.map.addInputListener(this)
-        mapWindow.map.setMapLoadedListener(this)
-    }
-
-    // REF
-    fun setCenter(position: CameraPosition?, duration: Float, animation: Int) {
-        if (duration > 0) {
-            val anim = if (animation == 0) Animation.Type.SMOOTH else Animation.Type.LINEAR
-            mapWindow.map.move(position!!, Animation(anim, duration), null)
-        } else {
-            mapWindow.map.move(position!!)
-        }
-    }
-
-    fun setViewParent(viewParent: ViewParent?) { //any ViewGroup
-        mViewParent = viewParent
-    }
-
-    override fun onInterceptTouchEvent(event: MotionEvent): Boolean {
-        when (event.getAction()) {
-            MotionEvent.ACTION_DOWN -> if (null == mViewParent) {
-                parent.requestDisallowInterceptTouchEvent(true)
-            } else {
-                mViewParent!!.requestDisallowInterceptTouchEvent(true)
-            }
-
-            MotionEvent.ACTION_UP -> if (null == mViewParent) {
-                parent.requestDisallowInterceptTouchEvent(false)
-            } else {
-                mViewParent!!.requestDisallowInterceptTouchEvent(false)
-            }
-
-            else -> {}
-        }
-        return super.onInterceptTouchEvent(event)
-    }
-
-    private fun positionToJSON(
-        position: CameraPosition,
-        reason: CameraUpdateReason,
-        finished: Boolean
-    ): WritableMap {
-        val cameraPosition = Arguments.createMap()
-        val point = position.target
-        cameraPosition.putDouble("azimuth", position.azimuth.toDouble())
-        cameraPosition.putDouble("tilt", position.tilt.toDouble())
-        cameraPosition.putDouble("zoom", position.zoom.toDouble())
-        val target = Arguments.createMap()
-        target.putDouble("lat", point.latitude)
-        target.putDouble("lon", point.longitude)
-        cameraPosition.putMap("point", target)
-        cameraPosition.putString("reason", reason.toString())
-        cameraPosition.putBoolean("finished", finished)
-
-        return cameraPosition
-    }
-
-    private fun screenPointToJSON(screenPoint: ScreenPoint?): WritableMap {
-        val result = Arguments.createMap()
-
-        result.putDouble("x", screenPoint!!.x.toDouble())
-        result.putDouble("y", screenPoint.y.toDouble())
-
-        return result
-    }
-
-    private fun worldPointToJSON(worldPoint: Point?): WritableMap {
-        val result = Arguments.createMap()
-
-        result.putDouble("lat", worldPoint!!.latitude)
-        result.putDouble("lon", worldPoint.longitude)
-
-        return result
-    }
-
-    private fun visibleRegionToJSON(region: VisibleRegion): WritableMap {
-        val result = Arguments.createMap()
-
-        val bl = Arguments.createMap()
-        bl.putDouble("lat", region.bottomLeft.latitude)
-        bl.putDouble("lon", region.bottomLeft.longitude)
-        result.putMap("bottomLeft", bl)
-
-        val br = Arguments.createMap()
-        br.putDouble("lat", region.bottomRight.latitude)
-        br.putDouble("lon", region.bottomRight.longitude)
-        result.putMap("bottomRight", br)
-
-        val tl = Arguments.createMap()
-        tl.putDouble("lat", region.topLeft.latitude)
-        tl.putDouble("lon", region.topLeft.longitude)
-        result.putMap("topLeft", tl)
-
-        val tr = Arguments.createMap()
-        tr.putDouble("lat", region.topRight.latitude)
-        tr.putDouble("lon", region.topRight.longitude)
-        result.putMap("topRight", tr)
-
-        return result
-    }
-
-    fun emitCameraPositionToJS(id: String?) {
-        val position = mapWindow.map.cameraPosition
-        val cameraPosition =
-            positionToJSON(position, CameraUpdateReason.valueOf("APPLICATION"), true)
-        cameraPosition.putString("id", id)
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java)
-            .receiveEvent(getId(), "cameraPosition", cameraPosition)
-    }
-
-    fun emitVisibleRegionToJS(id: String?) {
-        val visibleRegion = mapWindow.map.visibleRegion
-        val result = visibleRegionToJSON(visibleRegion)
-        result.putString("id", id)
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java)
-            .receiveEvent(getId(), "visibleRegion", result)
-    }
-
-    fun emitWorldToScreenPoints(worldPoints: ReadableArray, id: String?) {
-        val screenPoints = Arguments.createArray()
-
-        for (i in 0 until worldPoints.size()) {
-            val p = worldPoints.getMap(i)
-            val worldPoint = Point(p.getDouble("lat"), p.getDouble("lon"))
-            val screenPoint = mapWindow.worldToScreen(worldPoint)
-            screenPoints.pushMap(screenPointToJSON(screenPoint))
-        }
-
-        val result = Arguments.createMap()
-        result.putString("id", id)
-        result.putArray("screenPoints", screenPoints)
-
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java)
-            .receiveEvent(getId(), "worldToScreenPoints", result)
-    }
-
-    fun emitScreenToWorldPoints(screenPoints: ReadableArray, id: String?) {
-        val worldPoints = Arguments.createArray()
-
-        for (i in 0 until screenPoints.size()) {
-            val p = screenPoints.getMap(i)
-            val screenPoint = ScreenPoint(p.getDouble("x").toFloat(), p.getDouble("y").toFloat())
-            val worldPoint = mapWindow.screenToWorld(screenPoint)
-            worldPoints.pushMap(worldPointToJSON(worldPoint))
-        }
-
-        val result = Arguments.createMap()
-        result.putString("id", id)
-        result.putArray("worldPoints", worldPoints)
-
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java)
-            .receiveEvent(getId(), "screenToWorldPoints", result)
-    }
-
-    fun setZoom(zoom: Float?, duration: Float, animation: Int) {
-        val prevPosition = mapWindow.map.cameraPosition
-        val position =
-            CameraPosition(prevPosition.target, zoom!!, prevPosition.azimuth, prevPosition.tilt)
-        setCenter(position, duration, animation)
-    }
-
-    fun findRoutes(points: ArrayList<Point?>, vehicles: ArrayList<String>, id: String?) {
-        val self = this
-        if (vehicles.size == 1 && vehicles[0] == "car") {
-            val listener: DrivingRouteListener = object : DrivingRouteListener {
-                override fun onDrivingRoutes(routes: List<DrivingRoute>) {
-                    val jsonRoutes = Arguments.createArray()
-                    for (i in routes.indices) {
-                        val _route = routes[i]
-                        val jsonRoute = Arguments.createMap()
-                        val id = RouteManager.generateId()
-                        jsonRoute.putString("id", id)
-                        val sections = Arguments.createArray()
-                        for (section in _route.sections) {
-                            val jsonSection = convertDrivingRouteSection(_route, section, i)
-                            sections.pushMap(jsonSection)
-                        }
-                        jsonRoute.putArray("sections", sections)
-                        jsonRoutes.pushMap(jsonRoute)
-                    }
-                    self.onRoutesFound(id, jsonRoutes, "success")
-                }
-
-                override fun onDrivingRoutesError(error: Error) {
-                    self.onRoutesFound(id, Arguments.createArray(), "error")
-                }
-            }
-            val _points = ArrayList<RequestPoint>()
-            for (i in points.indices) {
-                val point = points[i]
-                val _p = RequestPoint(point!!, RequestPointType.WAYPOINT, null, null)
-                _points.add(_p)
-            }
-
-            drivingRouter.requestRoutes(
-                _points,
-                DrivingOptions().setRoutesCount(1),
-                VehicleOptions(),
-                listener
-            )
-            return
-        }
-        val _points = ArrayList<RequestPoint>()
-        for (i in points.indices) {
-            val point = points[i]
-            _points.add(RequestPoint(point!!, RequestPointType.WAYPOINT, null, null))
-        }
-        val listener: Session.RouteListener = object : Session.RouteListener {
-            override fun onMasstransitRoutes(routes: List<Route>) {
-                val jsonRoutes = Arguments.createArray()
-                for (i in routes.indices) {
-                    val _route = routes[i]
-                    val jsonRoute = Arguments.createMap()
-                    val id = RouteManager.generateId()
-                    self.routeMng.saveRoute(_route, id)
-                    jsonRoute.putString("id", id)
-                    val sections = Arguments.createArray()
-                    for (section in _route.sections) {
-                        val jsonSection = convertRouteSection(
-                            _route, section, SubpolylineHelper.subpolyline(
-                                _route.geometry,
-                                section.geometry
-                            ), _route.metadata.weight, i
-                        )
-                        sections.pushMap(jsonSection)
-                    }
-                    jsonRoute.putArray("sections", sections)
-                    jsonRoutes.pushMap(jsonRoute)
-                }
-                self.onRoutesFound(id, jsonRoutes, "success")
+open class YamapView(context: Context?) : MapView(context),
+  UserLocationObjectListener,
+  CameraListener,
+  InputListener,
+  TrafficListener,
+  MapLoadedListener {
+
+  private var mViewParent: ViewParent? = null
+  private var userLocationIcon = ""
+  private var userLocationIconScale = 1f
+  private var userLocationBitmap: Bitmap? = null
+
+  private val routeMng = RouteManager()
+  private var routeOptions: RouteOptions = RouteOptions(FitnessOptions())
+
+  private val masstransitRouter = TransportFactory.getInstance().createMasstransitRouter()
+  private val drivingRouter: DrivingRouter =
+    DirectionsFactory.getInstance().createDrivingRouter(DrivingRouterType.ONLINE)
+  private val pedestrianRouter = TransportFactory.getInstance().createPedestrianRouter()
+
+  private var userLocationLayer: UserLocationLayer? = null
+  private var userLocationAccuracyFillColor = 0
+  private var userLocationAccuracyStrokeColor = 0
+  private var userLocationAccuracyStrokeWidth = 0f
+  private var trafficLayer: TrafficLayer? = null
+  private var maxFps = 60f
+  private var initializedRegion = false
+
+  private var userLocationView: UserLocationView? = null
+
+  init {
+    mapWindow.map.addCameraListener(this)
+    mapWindow.map.addInputListener(this)
+    mapWindow.map.setMapLoadedListener(this)
+  }
+
+  // ===== helpers =====
+
+  fun setCenter(position: CameraPosition?, duration: Float, animation: Int) {
+    if (duration > 0) {
+      val anim = if (animation == 0) Animation.Type.SMOOTH else Animation.Type.LINEAR
+      mapWindow.map.move(position!!, Animation(anim, duration), null)
+    } else {
+      mapWindow.map.move(position!!)
+    }
+  }
+
+  fun setViewParent(viewParent: ViewParent?) {
+    mViewParent = viewParent
+  }
+
+  override fun onInterceptTouchEvent(event: MotionEvent): Boolean {
+    when (event.action) {
+      MotionEvent.ACTION_DOWN ->
+        (mViewParent ?: parent).requestDisallowInterceptTouchEvent(true)
+      MotionEvent.ACTION_UP ->
+        (mViewParent ?: parent).requestDisallowInterceptTouchEvent(false)
+    }
+    return super.onInterceptTouchEvent(event)
+  }
+
+  private fun positionToJSON(
+    position: CameraPosition,
+    reason: CameraUpdateReason,
+    finished: Boolean
+  ): WritableMap {
+    val cameraPosition = Arguments.createMap()
+    val point = position.target
+    cameraPosition.putDouble("azimuth", position.azimuth.toDouble())
+    cameraPosition.putDouble("tilt", position.tilt.toDouble())
+    cameraPosition.putDouble("zoom", position.zoom.toDouble())
+    val target = Arguments.createMap()
+    target.putDouble("lat", point.latitude)
+    target.putDouble("lon", point.longitude)
+    cameraPosition.putMap("point", target)
+    cameraPosition.putString("reason", reason.toString())
+    cameraPosition.putBoolean("finished", finished)
+    return cameraPosition
+  }
+
+  private fun screenPointToJSON(screenPoint: ScreenPoint): WritableMap =
+    Arguments.createMap().apply {
+      putDouble("x", screenPoint.x.toDouble())
+      putDouble("y", screenPoint.y.toDouble())
+    }
+
+  private fun worldPointToJSON(worldPoint: Point): WritableMap =
+    Arguments.createMap().apply {
+      putDouble("lat", worldPoint.latitude)
+      putDouble("lon", worldPoint.longitude)
+    }
+
+  private fun visibleRegionToJSON(region: VisibleRegion): WritableMap {
+    val result = Arguments.createMap()
+    fun putPoint(key: String, p: Point) =
+      Arguments.createMap().apply {
+        putDouble("lat", p.latitude)
+        putDouble("lon", p.longitude)
+      }.also { result.putMap(key, it) }
+
+    putPoint("bottomLeft", region.bottomLeft)
+    putPoint("bottomRight", region.bottomRight)
+    putPoint("topLeft", region.topLeft)
+    putPoint("topRight", region.topRight)
+    return result
+  }
+
+  fun emitCameraPositionToJS(id: String?) {
+    val position = mapWindow.map.cameraPosition
+    val cameraPosition = positionToJSON(position, CameraUpdateReason.valueOf("APPLICATION"), true)
+    cameraPosition.putString("id", id)
+    val reactContext = context as ReactContext
+    reactContext
+      .getJSModule(RCTEventEmitter::class.java)
+      .receiveEvent(getId(), "cameraPosition", cameraPosition)
+  }
+
+  fun emitVisibleRegionToJS(id: String?) {
+    val visibleRegion = mapWindow.map.visibleRegion
+    val result = visibleRegionToJSON(visibleRegion)
+    result.putString("id", id)
+    val reactContext = context as ReactContext
+    reactContext
+      .getJSModule(RCTEventEmitter::class.java)
+      .receiveEvent(getId(), "visibleRegion", result)
+  }
+
+  fun emitWorldToScreenPoints(worldPoints: ReadableArray, id: String?) {
+    val screenPointsArray = Arguments.createArray()
+    for (i in 0 until worldPoints.size()) {
+      val pointMap: ReadableMap? = worldPoints.getMap(i)
+      pointMap?.let {
+        if (it.hasKey("lat") && it.hasKey("lon")) {
+          val lat = it.getDouble("lat")
+          val lon = it.getDouble("lon")
+          val worldPoint = Point(lat, lon)
+          val screenPoint: ScreenPoint? = mapWindow.worldToScreen(worldPoint)
+          if (screenPoint != null) {
+            screenPointsArray.pushMap(screenPointToJSON(screenPoint))
+          }
+        }
+      }
+    }
+    val result = Arguments.createMap()
+    if (id != null) result.putString("id", id) else result.putNull("id")
+    result.putArray("screenPoints", screenPointsArray)
+    val reactContext = context as ReactContext
+    reactContext
+      .getJSModule(RCTEventEmitter::class.java)
+      .receiveEvent(getId(), "worldToScreenPoints", result)
+  }
+
+  fun emitScreenToWorldPoints(screenPoints: ReadableArray, id: String?) {
+    val worldPointsArray = Arguments.createArray()
+    for (i in 0 until screenPoints.size()) {
+      val pointMap: ReadableMap? = screenPoints.getMap(i)
+      pointMap?.let {
+        if (it.hasKey("x") && it.hasKey("y")) {
+          val x = it.getDouble("x").toFloat()
+          val y = it.getDouble("y").toFloat()
+          val screenPoint = ScreenPoint(x, y)
+          val worldPoint: Point? = mapWindow.screenToWorld(screenPoint)
+          if (worldPoint != null) {
+            worldPointsArray.pushMap(worldPointToJSON(worldPoint))
+          }
+        }
+      }
+    }
+    val result = Arguments.createMap()
+    if (id != null) result.putString("id", id) else result.putNull("id")
+    result.putArray("worldPoints", worldPointsArray)
+    val reactContext = context as ReactContext
+    reactContext
+      .getJSModule(RCTEventEmitter::class.java)
+      .receiveEvent(getId(), "screenToWorldPoints", result)
+  }
+
+  fun setZoom(zoom: Float?, duration: Float, animation: Int) {
+    val prevPosition = mapWindow.map.cameraPosition
+    val position = CameraPosition(prevPosition.target, zoom!!, prevPosition.azimuth, prevPosition.tilt)
+    setCenter(position, duration, animation)
+  }
+
+  // ===== routes =====
+
+  fun findRoutes(points: ArrayList<Point?>, vehicles: ArrayList<String>, id: String?) {
+    val self = this
+
+    // Машинные маршруты
+    if (vehicles.size == 1 && vehicles[0] == "car") {
+      val listener: DrivingRouteListener = object : DrivingRouteListener {
+        override fun onDrivingRoutes(routes: List<DrivingRoute>) {
+          val jsonRoutes = Arguments.createArray()
+          for (i in routes.indices) {
+            val _route = routes[i]
+            val jsonRoute = Arguments.createMap()
+            val rid = RouteManager.generateId()
+            jsonRoute.putString("id", rid)
+            val sections = Arguments.createArray()
+            for (section in _route.sections) {
+              val jsonSection = convertDrivingRouteSection(_route, section, i)
+              sections.pushMap(jsonSection)
             }
-
-            override fun onMasstransitRoutesError(error: Error) {
-                self.onRoutesFound(id, Arguments.createArray(), "error")
-            }
-        }
-        if (vehicles.size == 0) {
-            pedestrianRouter.requestRoutes(_points, TimeOptions(), routeOptions, listener)
-            return
-        }
-        val transitOptions = TransitOptions(FilterVehicleTypes.NONE.value, TimeOptions())
-        masstransitRouter.requestRoutes(_points, transitOptions, routeOptions, listener)
-    }
-
-    fun fitAllMarkers() {
-        val points = ArrayList<Point?>()
-        for (i in 0 until childCount) {
-            val obj: Any = getChildAt(i)
-            if (obj is YamapMarker) {
-                points.add(obj.point)
-            }
-        }
-        fitMarkers(points)
-    }
-
-    private fun mapPlacemarksToPoints(placemarks: List<PlacemarkMapObject>): ArrayList<Point> {
-        val points = ArrayList<Point>()
-
-        for (i in placemarks.indices) {
-            points.add(placemarks[i].geometry)
-        }
-
-        return points
-    }
-
-    fun calculateBoundingBox(points: ArrayList<Point?>): BoundingBox {
-        var minLon = points[0]!!.longitude
-        var maxLon = points[0]!!.longitude
-        var minLat = points[0]!!.latitude
-        var maxLat = points[0]!!.latitude
-
-        for (i in points.indices) {
-            if (points[i]!!.longitude > maxLon) {
-                maxLon = points[i]!!.longitude
-            }
-
-            if (points[i]!!.longitude < minLon) {
-                minLon = points[i]!!.longitude
-            }
-
-            if (points[i]!!.latitude > maxLat) {
-                maxLat = points[i]!!.latitude
-            }
-
-            if (points[i]!!.latitude < minLat) {
-                minLat = points[i]!!.latitude
-            }
-        }
-
-        val southWest = Point(minLat, minLon)
-        val northEast = Point(maxLat, maxLon)
-
-        val boundingBox = BoundingBox(southWest, northEast)
-        return boundingBox
-    }
-
-    fun fitMarkers(points: ArrayList<Point?>) {
-        if (points.size == 0) {
-            return
-        }
-        if (points.size == 1) {
-            val center = Point(
-                points[0]!!.latitude, points[0]!!.longitude
-            )
-            mapWindow.map.move(CameraPosition(center, 15f, 0f, 0f))
-            return
-        }
-        var cameraPosition = mapWindow.map.cameraPosition(Geometry.fromBoundingBox(calculateBoundingBox(points)))
-        cameraPosition = CameraPosition(
-            cameraPosition.target,
-            cameraPosition.zoom - 0.8f,
-            cameraPosition.azimuth,
-            cameraPosition.tilt
-        )
-        mapWindow.map.move(cameraPosition, Animation(Animation.Type.SMOOTH, 0.7f), null)
-    }
-
-    // PROPS
-    fun setUserLocationIcon(iconSource: String) {
-        // todo[0]: можно устанавливать разные иконки на покой и движение. Дополнительно можно устанавливать стиль иконки, например scale
-        userLocationIcon = iconSource
-        DownloadImageBitmap(context, iconSource, object : Callback<Bitmap?> {
-            override fun invoke(arg: Bitmap?) {
-                if (iconSource == userLocationIcon) {
-                    userLocationBitmap = arg
-                    updateUserLocationIcon()
-                }
-            }
-        })
-    }
-
-    fun setUserLocationIconScale(scale: Float) {
-        userLocationIconScale = scale
-        updateUserLocationIcon()
-    }
-
-    fun setUserLocationAccuracyFillColor(color: Int) {
-        userLocationAccuracyFillColor = color
-        updateUserLocationIcon()
-    }
-
-    fun setUserLocationAccuracyStrokeColor(color: Int) {
-        userLocationAccuracyStrokeColor = color
-        updateUserLocationIcon()
-    }
-
-    fun setUserLocationAccuracyStrokeWidth(width: Float) {
-        userLocationAccuracyStrokeWidth = width
-        updateUserLocationIcon()
-    }
-
-    fun setMapStyle(style: String?) {
-        if (style != null) {
-            mapWindow.map.setMapStyle(style)
-        }
-    }
-
-    fun setMapType(type: String?) {
-        if (type != null) {
-            when (type) {
-                "none" -> mapWindow.map.mapType = MapType.NONE
-                "raster" -> mapWindow.map.mapType = MapType.MAP
-                else -> mapWindow.map.mapType = MapType.VECTOR_MAP
-            }
-        }
-    }
-
-    fun setInitialRegion(params: ReadableMap?) {
-        if (initializedRegion) return
-        if ((!params!!.hasKey("lat") || params.isNull("lat")) || (!params.hasKey("lon") && params.isNull(
-                "lon"
-            ))
-        ) return
-
-        var initialRegionZoom = 10f
-        var initialRegionAzimuth = 0f
-        var initialRegionTilt = 0f
-
-        if (params.hasKey("zoom") && !params.isNull("zoom")) initialRegionZoom =
-            params.getDouble("zoom").toFloat()
-
-        if (params.hasKey("azimuth") && !params.isNull("azimuth")) initialRegionAzimuth =
-            params.getDouble("azimuth").toFloat()
-
-        if (params.hasKey("tilt") && !params.isNull("tilt")) initialRegionTilt =
-            params.getDouble("tilt").toFloat()
-
-        val initialPosition = Point(
-            params.getDouble("lat"), params.getDouble("lon")
+            jsonRoute.putArray("sections", sections)
+            jsonRoutes.pushMap(jsonRoute)
+          }
+          self.onRoutesFound(id, jsonRoutes, "success")
+        }
+
+        override fun onDrivingRoutesError(error: Error) {
+          self.onRoutesFound(id, Arguments.createArray(), "error")
+        }
+      }
+
+      val reqPoints = ArrayList<com.yandex.mapkit.RequestPoint>()
+      for (p in points) {
+        // строго 4 аргумента в 4.19, типы — явно через полный путь
+        reqPoints.add(
+          com.yandex.mapkit.RequestPoint(
+            p!!,
+            com.yandex.mapkit.RequestPointType.WAYPOINT,
+            null as String?,
+            null as String?,
+            null as String?
+          )
         )
-        val initialCameraPosition = CameraPosition(
-            initialPosition,
-            initialRegionZoom,
-            initialRegionAzimuth,
-            initialRegionTilt
+      }
+
+      drivingRouter.requestRoutes(
+        reqPoints,
+        DrivingOptions().setRoutesCount(1),
+        VehicleOptions(),
+        listener
+      )
+      return
+    }
+
+    // Пешком / ОТ
+    val reqPoints = ArrayList<com.yandex.mapkit.RequestPoint>()
+    for (p in points) {
+      reqPoints.add(
+        com.yandex.mapkit.RequestPoint(
+          p!!,
+          com.yandex.mapkit.RequestPointType.WAYPOINT,
+          null as String?,
+          null as String?,
+          null as String?
         )
-        setCenter(initialCameraPosition, 0f, 0)
-        initializedRegion = true
-    }
-
-    fun setLogoPosition(params: ReadableMap?) {
-        var horizontalAlignment = HorizontalAlignment.RIGHT
-        var verticalAlignment = VerticalAlignment.BOTTOM
-
-        if (params!!.hasKey("horizontal") && !params.isNull("horizontal")) {
-            when (params.getString("horizontal")) {
-                "left" -> horizontalAlignment = HorizontalAlignment.LEFT
-                "center" -> horizontalAlignment = HorizontalAlignment.CENTER
-                else -> {}
-            }
-        }
-
-        if (params.hasKey("vertical") && !params.isNull("vertical")) {
-            when (params.getString("vertical")) {
-                "top" -> verticalAlignment = VerticalAlignment.TOP
-                else -> {}
-            }
-        }
-
-        mapWindow.map.logo.setAlignment(Alignment(horizontalAlignment, verticalAlignment))
-    }
-
-    fun setLogoPadding(params: ReadableMap?) {
-        val horizontalPadding =
-            if ((params!!.hasKey("horizontal") && !params.isNull("horizontal"))) params.getInt("horizontal") else 0
-        val verticalPadding =
-            if ((params.hasKey("vertical") && !params.isNull("vertical"))) params.getInt("vertical") else 0
-        mapWindow.map.logo.setPadding(Padding(horizontalPadding, verticalPadding))
-    }
-
-    fun setMaxFps(fps: Float) {
-        maxFps = fps
-//        mapWindow.setMaxFps(maxFps)
-    }
-
-    fun setInteractive(interactive: Boolean) {
-        setNoninteractive(!interactive)
-    }
-
-    fun setNightMode(nightMode: Boolean?) {
-        mapWindow.map.isNightModeEnabled = nightMode!!
-    }
-
-    fun setScrollGesturesEnabled(scrollGesturesEnabled: Boolean?) {
-        mapWindow.map.isScrollGesturesEnabled = scrollGesturesEnabled!!
-    }
-
-    fun setZoomGesturesEnabled(zoomGesturesEnabled: Boolean?) {
-        mapWindow.map.isZoomGesturesEnabled = zoomGesturesEnabled!!
-    }
-
-    fun setRotateGesturesEnabled(rotateGesturesEnabled: Boolean?) {
-        mapWindow.map.isRotateGesturesEnabled = rotateGesturesEnabled!!
-    }
-
-    fun setFastTapEnabled(fastTapEnabled: Boolean?) {
-        mapWindow.map.isFastTapEnabled = fastTapEnabled!!
-    }
-
-    fun setTiltGesturesEnabled(tiltGesturesEnabled: Boolean?) {
-        mapWindow.map.isTiltGesturesEnabled = tiltGesturesEnabled!!
-    }
-
-    fun setTrafficVisible(isVisible: Boolean) {
-        if (trafficLayer == null) {
-            trafficLayer = MapKitFactory.getInstance().createTrafficLayer(mapWindow)
-        }
-
-        if (isVisible) {
-            trafficLayer!!.addTrafficListener(this)
-            trafficLayer!!.isTrafficVisible = true
-        } else {
-            trafficLayer!!.isTrafficVisible = false
-            trafficLayer!!.removeTrafficListener(this)
-        }
-    }
-
-    fun setShowUserPosition(show: Boolean) {
-        if (userLocationLayer == null) {
-            userLocationLayer = MapKitFactory.getInstance().createUserLocationLayer(mapWindow)
-        }
-
-        if (show) {
-            userLocationLayer!!.setObjectListener(this)
-            userLocationLayer!!.isVisible = true
-            userLocationLayer!!.isHeadingEnabled = true
-        } else {
-            userLocationLayer!!.isVisible = false
-            userLocationLayer!!.isHeadingEnabled = false
-            userLocationLayer!!.setObjectListener(null)
-        }
-    }
-
-    fun setFollowUser(follow: Boolean) {
-        if (userLocationLayer == null) {
-            setShowUserPosition(true)
-        }
-
-        if (follow) {
-            userLocationLayer!!.isAutoZoomEnabled = true
-            userLocationLayer!!.setAnchor(
-                PointF((width * 0.5).toFloat(), (height * 0.5).toFloat()),
-                PointF((width * 0.5).toFloat(), (height * 0.83).toFloat())
+      )
+    }
+
+    val listener: Session.RouteListener = object : Session.RouteListener {
+      override fun onMasstransitRoutes(routes: List<Route>) {
+        val jsonRoutes = Arguments.createArray()
+        for (i in routes.indices) {
+          val _route = routes[i]
+          val jsonRoute = Arguments.createMap()
+          val rid = RouteManager.generateId()
+          self.routeMng.saveRoute(_route, rid)
+          jsonRoute.putString("id", rid)
+          val sections = Arguments.createArray()
+          for (section in _route.sections) {
+            val jsonSection = convertRouteSection(
+              _route,
+              section,
+              SubpolylineHelper.subpolyline(_route.geometry, section.geometry),
+              _route.metadata.weight,
+              i
             )
-        } else {
-            userLocationLayer!!.isAutoZoomEnabled = false
-            userLocationLayer!!.resetAnchor()
-        }
-    }
-
-    private fun convertRouteSection(
-        route: Route,
-        section: Section,
-        geometry: Polyline,
-        routeWeight: Weight,
-        routeIndex: Int
-    ): WritableMap {
-        val data = section.metadata.data
-        val routeMetadata = Arguments.createMap()
-        val routeWeightData = Arguments.createMap()
-        val sectionWeightData = Arguments.createMap()
-        val transports: MutableMap<String, ArrayList<String?>?> = HashMap()
-        routeWeightData.putString("time", routeWeight.time.text)
-        routeWeightData.putInt("transferCount", routeWeight.transfersCount)
-        routeWeightData.putDouble("walkingDistance", routeWeight.walkingDistance.value)
-        sectionWeightData.putString("time", section.metadata.weight.time.text)
-        sectionWeightData.putInt("transferCount", section.metadata.weight.transfersCount)
-        sectionWeightData.putDouble(
-            "walkingDistance",
-            section.metadata.weight.walkingDistance.value
-        )
-        routeMetadata.putMap("sectionInfo", sectionWeightData)
-        routeMetadata.putMap("routeInfo", routeWeightData)
-        routeMetadata.putInt("routeIndex", routeIndex)
-        val stops: WritableArray = WritableNativeArray()
-
-        for (stop in section.stops) {
-            stops.pushString(stop.metadata.stop.name)
-        }
-
-        routeMetadata.putArray("stops", stops)
-
-        if (data.transports != null) {
-            for (transport in data.transports!!) {
-                for (type in transport.line.vehicleTypes) {
-                    if (type == "suburban") continue
-                    if (transports[type] != null) {
-                        val list = transports[type]
-                        if (list != null) {
-                            list.add(transport.line.name)
-                            transports[type] = list
-                        }
-                    } else {
-                        val list = ArrayList<String?>()
-                        list.add(transport.line.name)
-                        transports[type] = list
-                    }
-                    routeMetadata.putString("type", type)
-                    var color = Color.BLACK
-                    if (transportHasStyle(transport)) {
-                        try {
-                            color = transport.line.style!!.color!!
-                        } catch (ignored: Exception) {
-                        }
-                    }
-                    routeMetadata.putString("sectionColor", formatColor(color))
-                }
-            }
-        } else {
-            routeMetadata.putString("sectionColor", formatColor(Color.DKGRAY))
-            if (section.metadata.weight.walkingDistance.value == 0.0) {
-                routeMetadata.putString("type", "waiting")
-            } else {
-                routeMetadata.putString("type", "walk")
-            }
-        }
-
-        val wTransports = Arguments.createMap()
-
-        for ((key, value) in transports) {
-            wTransports.putArray(key, Arguments.fromList(value))
-        }
-
-        routeMetadata.putMap("transports", wTransports)
-        val subpolyline = SubpolylineHelper.subpolyline(route.geometry, section.geometry)
-        val linePoints = subpolyline.points
-        val jsonPoints = Arguments.createArray()
-
-        for (point in linePoints) {
-            val jsonPoint = Arguments.createMap()
-            jsonPoint.putDouble("lat", point.latitude)
-            jsonPoint.putDouble("lon", point.longitude)
-            jsonPoints.pushMap(jsonPoint)
-        }
-
-        routeMetadata.putArray("points", jsonPoints)
-
-        return routeMetadata
-    }
-
-    private fun convertDrivingRouteSection(
-        route: DrivingRoute,
-        section: DrivingSection,
-        routeIndex: Int
-    ): WritableMap {
-        val routeWeight = route.metadata.weight
-        val routeMetadata = Arguments.createMap()
-        val routeWeightData = Arguments.createMap()
-        val sectionWeightData = Arguments.createMap()
-        routeWeightData.putString("time", routeWeight.time.text)
-        routeWeightData.putString("timeWithTraffic", routeWeight.timeWithTraffic.text)
-        routeWeightData.putDouble("distance", routeWeight.distance.value)
-        sectionWeightData.putString("time", section.metadata.weight.time.text)
-        sectionWeightData.putString("timeWithTraffic", section.metadata.weight.timeWithTraffic.text)
-        sectionWeightData.putDouble("distance", section.metadata.weight.distance.value)
-        routeMetadata.putMap("sectionInfo", sectionWeightData)
-        routeMetadata.putMap("routeInfo", routeWeightData)
-        routeMetadata.putInt("routeIndex", routeIndex)
-        val stops: WritableArray = WritableNativeArray()
-        routeMetadata.putArray("stops", stops)
-        routeMetadata.putString("sectionColor", formatColor(Color.DKGRAY))
-
-        if (section.metadata.weight.distance.value == 0.0) {
-            routeMetadata.putString("type", "waiting")
-        } else {
-            routeMetadata.putString("type", "car")
-        }
-
-        val wTransports = Arguments.createMap()
-        routeMetadata.putMap("transports", wTransports)
-        val subpolyline = SubpolylineHelper.subpolyline(route.geometry, section.geometry)
-        val linePoints = subpolyline.points
-        val jsonPoints = Arguments.createArray()
-
-        for (point in linePoints) {
-            val jsonPoint = Arguments.createMap()
-            jsonPoint.putDouble("lat", point.latitude)
-            jsonPoint.putDouble("lon", point.longitude)
-            jsonPoints.pushMap(jsonPoint)
-        }
-
-        routeMetadata.putArray("points", jsonPoints)
-
-        return routeMetadata
-    }
-
-    fun onRoutesFound(id: String?, routes: WritableArray?, status: String?) {
-        val event = Arguments.createMap()
-        event.putArray("routes", routes)
-        event.putString("id", id)
-        event.putString("status", status)
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java).receiveEvent(getId(), "routes", event)
-    }
-
-    private fun transportHasStyle(transport: Transport): Boolean {
-        return transport.line.style != null
-    }
-
-    private fun formatColor(color: Int): String {
-        return String.format("#%06X", (0xFFFFFF and color))
-    }
-
-    // CHILDREN
-    open fun addFeature(child: View?, index: Int) {
-        if (child is YamapPolygon) {
-            val _child = child
-            val obj = mapWindow.map.mapObjects.addPolygon(_child.polygon)
-            _child.setPolygonMapObject(obj)
-        } else if (child is YamapPolyline) {
-            val _child = child
-            val obj = mapWindow.map.mapObjects.addPolyline(_child.polyline)
-            _child.setPolylineMapObject(obj)
-        } else if (child is YamapMarker) {
-            val _child = child
-            val obj = mapWindow.map.mapObjects.addPlacemark(_child.point!!)
-            _child.setMarkerMapObject(obj)
-        } else if (child is YamapCircle) {
-            val _child = child
-            val obj = mapWindow.map.mapObjects.addCircle(_child.circle)
-            _child.setCircleMapObject(obj)
-        }
-    }
-
-    open fun removeChild(index: Int) {
-        if (getChildAt(index) is ReactMapObject) {
-            val child = getChildAt(index) as ReactMapObject ?: return
-            val mapObject = child.rnMapObject
-            if (mapObject == null || !mapObject.isValid) return
-
-            mapWindow.map.mapObjects.remove(mapObject)
-        }
-    }
-
-    // location listener implementation
-    override fun onObjectAdded(@Nonnull _userLocationView: UserLocationView) {
-        userLocationView = _userLocationView
-        updateUserLocationIcon()
-    }
-
-    override fun onObjectRemoved(@Nonnull userLocationView: UserLocationView) {
-    }
-
-    override fun onObjectUpdated(
-        @Nonnull _userLocationView: UserLocationView,
-        @Nonnull objectEvent: ObjectEvent
-    ) {
-        userLocationView = _userLocationView
-        updateUserLocationIcon()
-    }
-
-    private fun updateUserLocationIcon() {
-        if (userLocationView != null) {
-            val userIconStyle = IconStyle()
-            userIconStyle.setScale(userLocationIconScale)
-
-            val pin = userLocationView!!.pin
-            val arrow = userLocationView!!.arrow
-            if (userLocationBitmap != null) {
-                pin.setIcon(ImageProvider.fromBitmap(userLocationBitmap), userIconStyle)
-                arrow.setIcon(ImageProvider.fromBitmap(userLocationBitmap), userIconStyle)
-            }
-            val circle = userLocationView!!.accuracyCircle
-            if (userLocationAccuracyFillColor != 0) {
-                circle.fillColor = userLocationAccuracyFillColor
-            }
-            if (userLocationAccuracyStrokeColor != 0) {
-                circle.strokeColor = userLocationAccuracyStrokeColor
-            }
-            circle.strokeWidth = userLocationAccuracyStrokeWidth
-        }
-    }
-
-    override fun onCameraPositionChanged(
-        map: com.yandex.mapkit.map.Map,
-        cameraPosition: CameraPosition,
-        reason: CameraUpdateReason,
-        finished: Boolean
-    ) {
-        val positionStart = positionToJSON(cameraPosition, reason, finished)
-        val positionFinish = positionToJSON(cameraPosition, reason, finished)
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java)
-            .receiveEvent(id, "cameraPositionChange", positionStart)
-
-        if (finished) {
-            reactContext.getJSModule(RCTEventEmitter::class.java)
-                .receiveEvent(id, "cameraPositionChangeEnd", positionFinish)
-        }
-    }
-
-    override fun onMapTap(map: com.yandex.mapkit.map.Map, point: Point) {
-        val data = Arguments.createMap()
-        data.putDouble("lat", point.latitude)
-        data.putDouble("lon", point.longitude)
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onMapPress", data)
-    }
-
-    override fun onMapLongTap(map: com.yandex.mapkit.map.Map, point: Point) {
-        val data = Arguments.createMap()
-        data.putDouble("lat", point.latitude)
-        data.putDouble("lon", point.longitude)
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java)
-            .receiveEvent(id, "onMapLongPress", data)
-    }
-
-    override fun onMapLoaded(statistics: MapLoadStatistics) {
-        val data = Arguments.createMap()
-        data.putInt("renderObjectCount", statistics.renderObjectCount)
-        data.putDouble("curZoomModelsLoaded", statistics.curZoomModelsLoaded.toDouble())
-        data.putDouble("curZoomPlacemarksLoaded", statistics.curZoomPlacemarksLoaded.toDouble())
-        data.putDouble("curZoomLabelsLoaded", statistics.curZoomLabelsLoaded.toDouble())
-        data.putDouble("curZoomGeometryLoaded", statistics.curZoomGeometryLoaded.toDouble())
-        data.putDouble("tileMemoryUsage", statistics.tileMemoryUsage.toDouble())
-        data.putDouble("delayedGeometryLoaded", statistics.delayedGeometryLoaded.toDouble())
-        data.putDouble("fullyAppeared", statistics.fullyAppeared.toDouble())
-        data.putDouble("fullyLoaded", statistics.fullyLoaded.toDouble())
-        val reactContext = context as ReactContext
-        reactContext.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onMapLoaded", data)
-    }
-
-    //trafficListener implementation
-    override fun onTrafficChanged(trafficLevel: TrafficLevel?) {
-    }
-
-    override fun onTrafficLoading() {
-    }
-
-    override fun onTrafficExpired() {
-    }
-
-    companion object {
-        private val DEFAULT_VEHICLE_COLORS: HashMap<String?, String?> =
-            object : HashMap<String?, String?>() {
-                init {
-                    put("bus", "#59ACFF")
-                    put("railway", "#F8634F")
-                    put("tramway", "#C86DD7")
-                    put("suburban", "#3023AE")
-                    put("underground", "#BDCCDC")
-                    put("trolleybus", "#55CfDC")
-                    put("walk", "#333333")
-                }
-            }
-    }
+            sections.pushMap(jsonSection)
+          }
+          jsonRoute.putArray("sections", sections)
+          jsonRoutes.pushMap(jsonRoute)
+        }
+        self.onRoutesFound(id, jsonRoutes, "success")
+      }
+
+      override fun onMasstransitRoutesError(error: Error) {
+        self.onRoutesFound(id, Arguments.createArray(), "error")
+      }
+    }
+
+    if (vehicles.isEmpty()) {
+      pedestrianRouter.requestRoutes(reqPoints, TimeOptions(), routeOptions, listener)
+      return
+    }
+    val transitOptions = TransitOptions(FilterVehicleTypes.NONE.value, TimeOptions())
+    masstransitRouter.requestRoutes(reqPoints, transitOptions, routeOptions, listener)
+  }
+
+  fun fitAllMarkers() {
+    val points = ArrayList<Point?>()
+    for (i in 0 until childCount) {
+      val obj: Any = getChildAt(i)
+      if (obj is YamapMarker) points.add(obj.point)
+    }
+    fitMarkers(points)
+  }
+
+  private fun mapPlacemarksToPoints(placemarks: List<PlacemarkMapObject>): ArrayList<Point> =
+    ArrayList<Point>().apply { placemarks.forEach { add(it.geometry) } }
+
+  fun calculateBoundingBox(points: ArrayList<Point?>): BoundingBox {
+    var minLon = points[0]!!.longitude
+    var maxLon = points[0]!!.longitude
+    var minLat = points[0]!!.latitude
+    var maxLat = points[0]!!.latitude
+    for (p in points) {
+      if (p!!.longitude > maxLon) maxLon = p.longitude
+      if (p.longitude < minLon) minLon = p.longitude
+      if (p.latitude > maxLat) maxLat = p.latitude
+      if (p.latitude < minLat) minLat = p.latitude
+    }
+    return BoundingBox(Point(minLat, minLon), Point(maxLat, maxLon))
+  }
+
+  fun fitMarkers(points: ArrayList<Point?>) {
+    if (points.isEmpty()) return
+    if (points.size == 1) {
+      val center = Point(points[0]!!.latitude, points[0]!!.longitude)
+      mapWindow.map.move(CameraPosition(center, 15f, 0f, 0f))
+      return
+    }
+    var cameraPosition = mapWindow.map.cameraPosition(Geometry.fromBoundingBox(calculateBoundingBox(points)))
+    cameraPosition = CameraPosition(
+      cameraPosition.target,
+      cameraPosition.zoom - 0.8f,
+      cameraPosition.azimuth,
+      cameraPosition.tilt
+    )
+    mapWindow.map.move(cameraPosition, Animation(Animation.Type.SMOOTH, 0.7f), null)
+  }
+
+  // ===== props from RN =====
+
+  fun setUserLocationIcon(iconSource: String) {
+    userLocationIcon = iconSource
+    DownloadImageBitmap(context, iconSource, object : Callback<Bitmap?> {
+      override fun invoke(arg: Bitmap?) {
+        if (iconSource == userLocationIcon) {
+          userLocationBitmap = arg
+          updateUserLocationIcon()
+        }
+      }
+    })
+  }
+
+  fun setUserLocationIconScale(scale: Float) {
+    userLocationIconScale = scale
+    updateUserLocationIcon()
+  }
+
+  fun setUserLocationAccuracyFillColor(color: Int) {
+    userLocationAccuracyFillColor = color
+    updateUserLocationIcon()
+  }
+
+  fun setUserLocationAccuracyStrokeColor(color: Int) {
+    userLocationAccuracyStrokeColor = color
+    updateUserLocationIcon()
+  }
+
+  fun setUserLocationAccuracyStrokeWidth(width: Float) {
+    userLocationAccuracyStrokeWidth = width
+    updateUserLocationIcon()
+  }
+
+  fun setMapStyle(style: String?) {
+    if (style != null) mapWindow.map.setMapStyle(style)
+  }
+
+  fun setMapType(type: String?) {
+    if (type != null) {
+      mapWindow.map.mapType = when (type) {
+        "none" -> MapType.NONE
+        "raster" -> MapType.MAP
+        else -> MapType.VECTOR_MAP
+      }
+    }
+  }
+
+  fun setInitialRegion(params: ReadableMap?) {
+    if (initializedRegion || params == null) return
+    if (!params.hasKey("lat") || params.isNull("lat")) return
+    if (!params.hasKey("lon") || params.isNull("lon")) return
+
+    var zoom = 10f
+    var azimuth = 0f
+    var tilt = 0f
+    if (params.hasKey("zoom") && !params.isNull("zoom")) zoom = params.getDouble("zoom").toFloat()
+    if (params.hasKey("azimuth") && !params.isNull("azimuth")) azimuth = params.getDouble("azimuth").toFloat()
+    if (params.hasKey("tilt") && !params.isNull("tilt")) tilt = params.getDouble("tilt").toFloat()
+
+    val pos = Point(params.getDouble("lat"), params.getDouble("lon"))
+    val cam = CameraPosition(pos, zoom, azimuth, tilt)
+    setCenter(cam, 0f, 0)
+    initializedRegion = true
+  }
+
+  fun setLogoPosition(params: ReadableMap?) {
+    var h = HorizontalAlignment.RIGHT
+    var v = VerticalAlignment.BOTTOM
+    if (params != null) {
+      if (params.hasKey("horizontal") && !params.isNull("horizontal")) {
+        when (params.getString("horizontal")) {
+          "left" -> h = HorizontalAlignment.LEFT
+          "center" -> h = HorizontalAlignment.CENTER
+        }
+      }
+      if (params.hasKey("vertical") && !params.isNull("vertical")) {
+        if ("top" == params.getString("vertical")) v = VerticalAlignment.TOP
+      }
+    }
+    mapWindow.map.logo.setAlignment(Alignment(h, v))
+  }
+
+  fun setLogoPadding(params: ReadableMap?) {
+    val hp = if (params != null && params.hasKey("horizontal") && !params.isNull("horizontal")) params.getInt("horizontal") else 0
+    val vp = if (params != null && params.hasKey("vertical") && !params.isNull("vertical")) params.getInt("vertical") else 0
+    mapWindow.map.logo.setPadding(Padding(hp, vp))
+  }
+
+  fun setMaxFps(fps: Float) {
+    maxFps = fps
+    // mapWindow.setMaxFps(maxFps)
+  }
+
+  fun setInteractive(interactive: Boolean) {
+    setNoninteractive(!interactive)
+  }
+
+  fun setNightMode(nightMode: Boolean?) {
+    mapWindow.map.isNightModeEnabled = nightMode == true
+  }
+
+  fun setScrollGesturesEnabled(v: Boolean?) {
+    mapWindow.map.isScrollGesturesEnabled = v == true
+  }
+
+  fun setZoomGesturesEnabled(v: Boolean?) {
+    mapWindow.map.isZoomGesturesEnabled = v == true
+  }
+
+  fun setRotateGesturesEnabled(v: Boolean?) {
+    mapWindow.map.isRotateGesturesEnabled = v == true
+  }
+
+  fun setFastTapEnabled(v: Boolean?) {
+    mapWindow.map.isFastTapEnabled = v == true
+  }
+
+  fun setTiltGesturesEnabled(v: Boolean?) {
+    mapWindow.map.isTiltGesturesEnabled = v == true
+  }
+
+  fun setTrafficVisible(isVisible: Boolean) {
+    if (trafficLayer == null) {
+      trafficLayer = MapKitFactory.getInstance().createTrafficLayer(mapWindow)
+    }
+    if (isVisible) {
+      trafficLayer!!.addTrafficListener(this)
+      trafficLayer!!.isTrafficVisible = true
+    } else {
+      trafficLayer!!.isTrafficVisible = false
+      trafficLayer!!.removeTrafficListener(this)
+    }
+  }
+
+  fun setShowUserPosition(show: Boolean) {
+    if (userLocationLayer == null) {
+      userLocationLayer = MapKitFactory.getInstance().createUserLocationLayer(mapWindow)
+    }
+    userLocationLayer?.setObjectListener(if (show) this else null)
+    userLocationLayer?.setVisible(show)
+
+    // В некоторых версиях API нет метода setHeadingEnabled — пробуем через рефлексию.
+    try {
+      val m = userLocationLayer?.javaClass?.getMethod("setHeadingEnabled", Boolean::class.javaPrimitiveType)
+      m?.invoke(userLocationLayer, show)
+    } catch (_: Exception) {
+      // метода нет — просто пропускаем, функционал не критичен
+    }
+  }
+
+
+  fun setFollowUser(follow: Boolean) {
+    if (userLocationLayer == null) setShowUserPosition(true)
+    userLocationLayer?.setAutoZoomEnabled(follow)
+    if (follow) {
+      userLocationLayer?.setAnchor(
+        PointF(width * 0.5f, height * 0.5f),
+        PointF(width * 0.5f, height * 0.83f)
+      )
+    } else {
+      userLocationLayer?.resetAnchor()
+    }
+  }
+
+  private fun convertRouteSection(
+    route: Route,
+    section: Section,
+    geometry: Polyline,
+    routeWeight: Weight,
+    routeIndex: Int
+  ): WritableMap {
+    val data = section.metadata.data
+    val routeMetadata = Arguments.createMap()
+    val routeWeightData = Arguments.createMap()
+    val sectionWeightData = Arguments.createMap()
+    val transports: MutableMap<String, ArrayList<String?>?> = HashMap()
+
+    routeWeightData.putString("time", routeWeight.time.text)
+    routeWeightData.putInt("transferCount", routeWeight.transfersCount)
+    routeWeightData.putDouble("walkingDistance", routeWeight.walkingDistance.value)
+
+    sectionWeightData.putString("time", section.metadata.weight.time.text)
+    sectionWeightData.putInt("transferCount", section.metadata.weight.transfersCount)
+    sectionWeightData.putDouble("walkingDistance", section.metadata.weight.walkingDistance.value)
+
+    routeMetadata.putMap("sectionInfo", sectionWeightData)
+    routeMetadata.putMap("routeInfo", routeWeightData)
+    routeMetadata.putInt("routeIndex", routeIndex)
+
+    val stops: WritableArray = WritableNativeArray()
+    for (stop in section.stops) stops.pushString(stop.metadata.stop.name)
+    routeMetadata.putArray("stops", stops)
+
+    if (data.transports != null) {
+      for (transport in data.transports!!) {
+        for (type in transport.line.vehicleTypes) {
+          if (type == "suburban") continue
+          if (transports[type] != null) {
+            transports[type]!!.add(transport.line.name)
+          } else {
+            transports[type] = arrayListOf(transport.line.name)
+          }
+          routeMetadata.putString("type", type)
+          var color = Color.BLACK
+          if (transport.line.style != null) {
+            try { color = transport.line.style!!.color!! } catch (_: Exception) {}
+          }
+          routeMetadata.putString("sectionColor", formatColor(color))
+        }
+      }
+    } else {
+      routeMetadata.putString("sectionColor", formatColor(Color.DKGRAY))
+      routeMetadata.putString("type",
+        if (section.metadata.weight.walkingDistance.value == 0.0) "waiting" else "walk"
+      )
+    }
+
+    val wTransports = Arguments.createMap()
+    for ((key, value) in transports) {
+      wTransports.putArray(key, Arguments.fromList(value))
+    }
+    routeMetadata.putMap("transports", wTransports)
+
+    val subpolyline = SubpolylineHelper.subpolyline(route.geometry, section.geometry)
+    val linePoints = subpolyline.points
+    val jsonPoints = Arguments.createArray()
+    for (p in linePoints) {
+      val jp = Arguments.createMap()
+      jp.putDouble("lat", p.latitude)
+      jp.putDouble("lon", p.longitude)
+      jsonPoints.pushMap(jp)
+    }
+    routeMetadata.putArray("points", jsonPoints)
+    return routeMetadata
+  }
+
+  private fun convertDrivingRouteSection(
+    route: DrivingRoute,
+    section: DrivingSection,
+    routeIndex: Int
+  ): WritableMap {
+    val routeWeight = route.metadata.weight
+    val routeMetadata = Arguments.createMap()
+    val routeWeightData = Arguments.createMap()
+    val sectionWeightData = Arguments.createMap()
+
+    routeWeightData.putString("time", routeWeight.time.text)
+    routeWeightData.putString("timeWithTraffic", routeWeight.timeWithTraffic.text)
+    routeWeightData.putDouble("distance", routeWeight.distance.value)
+
+    sectionWeightData.putString("time", section.metadata.weight.time.text)
+    sectionWeightData.putString("timeWithTraffic", section.metadata.weight.timeWithTraffic.text)
+    sectionWeightData.putDouble("distance", section.metadata.weight.distance.value)
+
+    routeMetadata.putMap("sectionInfo", sectionWeightData)
+    routeMetadata.putMap("routeInfo", routeWeightData)
+    routeMetadata.putInt("routeIndex", routeIndex)
+
+    val stops: WritableArray = WritableNativeArray()
+    routeMetadata.putArray("stops", stops)
+    routeMetadata.putString("sectionColor", formatColor(Color.DKGRAY))
+    routeMetadata.putString("type",
+      if (section.metadata.weight.distance.value == 0.0) "waiting" else "car"
+    )
+
+    val wTransports = Arguments.createMap()
+    routeMetadata.putMap("transports", wTransports)
+
+    val subpolyline = SubpolylineHelper.subpolyline(route.geometry, section.geometry)
+    val linePoints = subpolyline.points
+    val jsonPoints = Arguments.createArray()
+    for (p in linePoints) {
+      val jp = Arguments.createMap()
+      jp.putDouble("lat", p.latitude)
+      jp.putDouble("lon", p.longitude)
+      jsonPoints.pushMap(jp)
+    }
+    routeMetadata.putArray("points", jsonPoints)
+    return routeMetadata
+  }
+
+  fun onRoutesFound(id: String?, routes: WritableArray?, status: String?) {
+    val event = Arguments.createMap()
+    event.putArray("routes", routes)
+    event.putString("id", id)
+    event.putString("status", status)
+    val reactContext = context as ReactContext
+    reactContext.getJSModule(RCTEventEmitter::class.java).receiveEvent(getId(), "routes", event)
+  }
+
+  private fun transportHasStyle(transport: Transport): Boolean =
+    transport.line.style != null
+
+  private fun formatColor(color: Int): String =
+    String.format("#%06X", (0xFFFFFF and color))
+
+  // ===== children =====
+
+  open fun addFeature(child: View?, index: Int) {
+    when (child) {
+      is YamapPolygon -> {
+        val obj = mapWindow.map.mapObjects.addPolygon(child.polygon)
+        child.setPolygonMapObject(obj)
+      }
+      is YamapPolyline -> {
+        val obj = mapWindow.map.mapObjects.addPolyline(child.polyline)
+        child.setPolylineMapObject(obj)
+      }
+      is YamapMarker -> {
+        val obj = mapWindow.map.mapObjects.addPlacemark(child.point!!)
+        child.setMarkerMapObject(obj)
+      }
+      is YamapCircle -> {
+        val obj = mapWindow.map.mapObjects.addCircle(child.circle)
+        child.setCircleMapObject(obj)
+      }
+    }
+  }
+
+  open fun removeChild(index: Int) {
+    val v = getChildAt(index)
+    if (v is ReactMapObject) {
+      val mapObject = v.rnMapObject ?: return
+      if (!mapObject.isValid) return
+      mapWindow.map.mapObjects.remove(mapObject)
+    }
+  }
+
+  // ===== user location listener =====
+
+  override fun onObjectAdded(@Nonnull _userLocationView: UserLocationView) {
+    userLocationView = _userLocationView
+    updateUserLocationIcon()
+  }
+
+  override fun onObjectRemoved(@Nonnull userLocationView: UserLocationView) {
+    // no-op
+  }
+
+  override fun onObjectUpdated(
+    @Nonnull _userLocationView: UserLocationView,
+    @Nonnull objectEvent: ObjectEvent
+  ) {
+    userLocationView = _userLocationView
+    updateUserLocationIcon()
+  }
+
+  private fun updateUserLocationIcon() {
+    val view = userLocationView ?: return
+    val userIconStyle = IconStyle().apply { setScale(userLocationIconScale) }
+
+    val pin = view.pin
+    val arrow = view.arrow
+    if (userLocationBitmap != null) {
+      pin.setIcon(ImageProvider.fromBitmap(userLocationBitmap), userIconStyle)
+      arrow.setIcon(ImageProvider.fromBitmap(userLocationBitmap), userIconStyle)
+    }
+
+    val circle = view.accuracyCircle
+    if (userLocationAccuracyFillColor != 0) circle.fillColor = userLocationAccuracyFillColor
+    if (userLocationAccuracyStrokeColor != 0) circle.strokeColor = userLocationAccuracyStrokeColor
+    circle.strokeWidth = userLocationAccuracyStrokeWidth
+  }
+
+  // ===== map/camera/traffic callbacks =====
+
+  override fun onCameraPositionChanged(
+    map: com.yandex.mapkit.map.Map,
+    cameraPosition: CameraPosition,
+    reason: CameraUpdateReason,
+    finished: Boolean
+  ) {
+    val positionStart = positionToJSON(cameraPosition, reason, finished)
+    val positionFinish = positionToJSON(cameraPosition, reason, finished)
+    val reactContext = context as ReactContext
+    reactContext.getJSModule(RCTEventEmitter::class.java)
+      .receiveEvent(id, "cameraPositionChange", positionStart)
+
+    if (finished) {
+      reactContext.getJSModule(RCTEventEmitter::class.java)
+        .receiveEvent(id, "cameraPositionChangeEnd", positionFinish)
+    }
+  }
+
+  override fun onMapTap(map: com.yandex.mapkit.map.Map, point: Point) {
+    val data = Arguments.createMap()
+    data.putDouble("lat", point.latitude)
+    data.putDouble("lon", point.longitude)
+    val reactContext = context as ReactContext
+    reactContext.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onMapPress", data)
+  }
+
+  override fun onMapLongTap(map: com.yandex.mapkit.map.Map, point: Point) {
+    val data = Arguments.createMap()
+    data.putDouble("lat", point.latitude)
+    data.putDouble("lon", point.longitude)
+    val reactContext = context as ReactContext
+    reactContext.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onMapLongPress", data)
+  }
+
+  override fun onMapLoaded(statistics: MapLoadStatistics) {
+    val data = Arguments.createMap()
+    data.putInt("renderObjectCount", statistics.renderObjectCount)
+    data.putDouble("curZoomModelsLoaded", statistics.curZoomModelsLoaded.toDouble())
+    data.putDouble("curZoomPlacemarksLoaded", statistics.curZoomPlacemarksLoaded.toDouble())
+    data.putDouble("curZoomLabelsLoaded", statistics.curZoomLabelsLoaded.toDouble())
+    data.putDouble("curZoomGeometryLoaded", statistics.curZoomGeometryLoaded.toDouble())
+    data.putDouble("tileMemoryUsage", statistics.tileMemoryUsage.toDouble())
+    data.putDouble("delayedGeometryLoaded", statistics.delayedGeometryLoaded.toDouble())
+    data.putDouble("fullyAppeared", statistics.fullyAppeared.toDouble())
+    data.putDouble("fullyLoaded", statistics.fullyLoaded.toDouble())
+    val reactContext = context as ReactContext
+    reactContext.getJSModule(RCTEventEmitter::class.java).receiveEvent(id, "onMapLoaded", data)
+  }
+
+  override fun onTrafficChanged(trafficLevel: TrafficLevel?) { }
+  override fun onTrafficLoading() { }
+  override fun onTrafficExpired() { }
+
+  companion object {
+    private val DEFAULT_VEHICLE_COLORS: HashMap<String?, String?> =
+      object : HashMap<String?, String?>() {
+        init {
+          put("bus", "#59ACFF")
+          put("railway", "#F8634F")
+          put("tramway", "#C86DD7")
+          put("suburban", "#3023AE")
+          put("underground", "#BDCCDC")
+          put("trolleybus", "#55CfDC")
+          put("walk", "#333333")
+        }
+      }
+  }
 }
